#!/bin/bash
# This script runs after a successful commit
# It reads configuration from .post-commit-config.yaml,
# stages any documentation changes generated by the pre-commit hook,
# creates a separate commit for them, and pushes to configured remotes

set -e  # Exit on error

# Get the project root directory
PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$PROJECT_DIR"

# Default configuration values
AUTO_STAGE=true
AUTO_COMMIT=true
AUTO_PUSH=true
DOC_COMMIT_MESSAGE="üìö Update documentation [Auto-generated]"
PUSH_ALL=true
SPECIFIC_REMOTES=("origin")
RUN_TESTS=false
BUILD_PACKAGE=false
NOTIFY=false

# Function to parse YAML (simple version)
parse_yaml() {
    local file=$1
    if [ -f "$file" ]; then
        # Extract auto_stage value
        if grep -q "auto_stage:" "$file"; then
            AUTO_STAGE=$(grep "auto_stage:" "$file" | awk '{print $2}')
        fi
        
        # Extract auto_commit value
        if grep -q "auto_commit:" "$file"; then
            AUTO_COMMIT=$(grep "auto_commit:" "$file" | awk '{print $2}')
        fi
        
        # Extract auto_push value
        if grep -q "auto_push:" "$file"; then
            AUTO_PUSH=$(grep "auto_push:" "$file" | awk '{print $2}')
        fi
        
        # Extract doc_commit_message value
        if grep -q "doc_commit_message:" "$file"; then
            DOC_COMMIT_MESSAGE=$(grep "doc_commit_message:" "$file" | cut -d ':' -f2- | sed 's/^[ \t]*//')
            # Remove quotes if present
            DOC_COMMIT_MESSAGE=$(echo "$DOC_COMMIT_MESSAGE" | sed 's/^"\(.*\)"$/\1/' | sed "s/^'\(.*\)'$/\1/")
        fi
        
        # Extract push_all value
        if grep -q "push_all:" "$file"; then
            PUSH_ALL=$(grep "push_all:" "$file" | awk '{print $2}')
        fi
        
        # Extract run_tests value
        if grep -q "run_tests:" "$file"; then
            RUN_TESTS=$(grep "run_tests:" "$file" | awk '{print $2}')
        fi
        
        # Extract build_package value
        if grep -q "build_package:" "$file"; then
            BUILD_PACKAGE=$(grep "build_package:" "$file" | awk '{print $2}')
        fi
        
        # Extract notify value
        if grep -q "notify:" "$file"; then
            NOTIFY=$(grep "notify:" "$file" | awk '{print $2}')
        fi
    fi
}

# Parse configuration file
CONFIG_FILE="${PROJECT_DIR}/.post-commit-config.yaml"
if [ -f "$CONFIG_FILE" ]; then
    echo "üìÑ Reading configuration from ${CONFIG_FILE}"
    parse_yaml "$CONFIG_FILE"
else
    echo "‚ö†Ô∏è No configuration file found at ${CONFIG_FILE}, using defaults"
fi

# Print configuration
echo "üîß Post-commit configuration:"
echo "  - Auto-stage changes: ${AUTO_STAGE}"
echo "  - Auto-commit changes: ${AUTO_COMMIT}"
echo "  - Auto-push changes: ${AUTO_PUSH}"
echo "  - Push to all remotes: ${PUSH_ALL}"

# Run tests if configured
if [ "$RUN_TESTS" = "true" ]; then
    echo "üß™ Running tests..."
    cd "$PROJECT_DIR" && poetry run pytest --cov=create_python_project tests/
    
    if [ $? -ne 0 ]; then
        echo "‚ùå Error: Tests failed. Please fix the issues before pushing."
        exit 1
    fi
    
    echo "‚úÖ Tests completed successfully."
fi

# Build package if configured
if [ "$BUILD_PACKAGE" = "true" ]; then
    echo "üì¶ Building package..."
    cd "$PROJECT_DIR" && poetry build
    
    if [ $? -ne 0 ]; then
        echo "‚ùå Error: Package build failed. Please fix the issues before pushing."
        exit 1
    fi
    
    echo "‚úÖ Package built successfully."
fi

# Check if there are unstaged documentation changes
if [ "$AUTO_STAGE" = "true" ] && git status --porcelain | grep -q "^?? \|^ M \|^MM " ; then
    echo "üìù Found unstaged changes after pre-commit hooks ran."
    
    # Stage all changes
    git add .
    echo "‚úÖ Changes staged."
    
    if [ "$AUTO_COMMIT" = "true" ]; then
        # Create a separate commit for documentation updates
        git commit -m "${DOC_COMMIT_MESSAGE}" || {
            echo "‚ùå Error: Could not create documentation commit. Manual intervention required."
            exit 1
        }
        echo "‚úÖ Documentation changes committed."
    fi
fi

# Push changes if configured
if [ "$AUTO_PUSH" = "true" ]; then
    if [ "$PUSH_ALL" = "true" ]; then
        # Push to all remotes
        echo "üöÄ Pushing changes to all remotes..."
        git push --all || {
            echo "‚ùå Error: Push failed. You may need to pull changes first or resolve conflicts."
            exit 1
        }
    else
        # Push to specific remotes
        for remote in "${SPECIFIC_REMOTES[@]}"; do
            echo "üöÄ Pushing changes to ${remote}..."
            git push "$remote" || {
                echo "‚ùå Error: Push to ${remote} failed. You may need to pull changes first or resolve conflicts."
                exit 1
            }
        done
    fi
    echo "‚úÖ Push completed successfully."
    
    # Send notification if configured
    if [ "$NOTIFY" = "true" ]; then
        echo "üîî Sending notification..."
        # This would be replaced with an actual notification command
        # For example: notify-send "Git Push" "Changes pushed successfully"
        echo "‚úÖ Notification sent."
    fi
fi

echo "‚ú® Post-commit process completed successfully."
