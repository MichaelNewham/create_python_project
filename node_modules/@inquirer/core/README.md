# `@inquirer/core`

The `@inquirer/core` package is the library enabling the creation of Inquirer prompts.

It aims to implements a lightweight API similar to React hooks - but without JSX.

# Special Thanks

<div align="center" markdown="1">

[![Graphite](https://github.com/user-attachments/assets/53db40ca-2254-481a-a094-6597f8716e29)](https://graphite.dev/?utm_source=npmjs&utm_medium=repo&utm_campaign=inquirerjs)<br>

### [Graphite is the AI developer productivity platform helping teams on GitHub ship higher quality software, faster](https://graphite.dev/?utm_source=npmjs&utm_medium=repo&utm_campaign=inquirerjs)

</div>

# Installation

<table>
<tr>
  <th>npm</th>
  <th>yarn</th>
</tr>
<tr>
<td>

```sh
npm install @inquirer/core
```

</td>
<td>

```sh
yarn add @inquirer/core
```

</td>
</tr>
</table>

# Usage

## Basic concept

Visual terminal apps are at their core strings rendered onto the terminal.

The most basic prompt is a function returning a string that'll be rendered in the terminal. This function will run every time the prompt state change, and the new returned string will replace the previously rendered one. The prompt cursor appears after the string.

Wrapping the rendering function with `createPrompt()` will setup the rendering layer, inject the state management utilities, and wait until the `done` callback is called.

```ts
import { createPrompt } from '@inquirer/core';

const input = createPrompt((config, done) => {
  // Implement logic

  return '? My question';
});

// And it is then called as
const answer = await input({
  /* config */
});
```

## Hooks

State management and user interactions are handled through hooks. Hooks are common [within the React ecosystem](https://react.dev/reference/react/hooks), and Inquirer reimplement the common ones.

### State hook

State lets a component “remember” information like user input. For example, an input prompt can use state to store the input value, while a list prompt can use state to track the cursor index.

`useState` declares a state variable that you can update directly.

```ts
import { createPrompt, useState } from '@inquirer/core';

const input = createPrompt((config, done) => {
  const [index, setIndex] = useState(0);

  // ...
```

### Keypress hook

Almost all prompts need to react to user actions. In a terminal, this is done through typing.

`useKeypress` allows you to react to keypress events, and access the prompt line.

```ts
const input = createPrompt((config, done) => {
  useKeypress((key) => {
    if (key.name === 'enter') {
      done(answer);
    }
  });

  // ...
```

Behind the scenes, Inquirer prompts are wrappers around [readlines](https://nodejs.org/api/readline.html). Aside the keypress event object, the hook also pass the active readline instance to the event handler.

```ts
const input = createPrompt((config, done) => {
  useKeypress((key, readline) => {
    setValue(readline.line);
  });

  // ...
```

### Ref hook

Refs let a prompt hold some information that isn’t used for rendering, like a class instance or a timeout ID. Unlike with state, updating a ref does not re-render your prompt. Refs are an “escape hatch” from the rendering paradigm.

`useRef` declares a ref. You can hold any value in it, but most often it’s used to hold a timeout ID.

```ts
const input = createPrompt((config, done) => {
  const timeout = useRef(null);

  // ...
```

### Effect Hook

Effects let a prompt connect to and synchronize with external systems. This includes dealing with network or animations.

`useEffect` connects a component to an external system.

```ts
const chat = createPrompt((config, done) => {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  // ...
```

### Performance hook


---

**Note:** This file has been automatically truncated to 150 lines maximum.
Full content was 393 lines. Last updated: 2025-05-16 01:43:46
